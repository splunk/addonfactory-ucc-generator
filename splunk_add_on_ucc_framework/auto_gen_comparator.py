#
# Copyright 2024 Splunk Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import sys
from os import walk
from os.path import sep
from typing import List, Dict, Any, Union
from logging import Logger
import addonfactory_splunk_conf_parser_lib as conf_parser
from lxml import etree, objectify

if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal


class CodeGeneratorDiffChecker:
    COMMON_FILES_MESSAGE_PART_1 = (
        "Below are the file(s) that are auto generated by the UCC framework. "
        "The below files can be removed from your repository:"
    )
    COMMON_FILES_MESSAGE_PART_2 = (
        "Please refer UCC framework documentation for the latest "
        "features that allows you to remove the above files."
    )
    DIFFERENT_FILES_MESSAGE = (
        "Below are the file(s) with the differences that are not auto generated by the UCC framework. "
        "(Optionally), you can raise feature requests for UCC framework at "
        "'https://github.com/splunk/addonfactory-ucc-generator/issues/new/choose' "
        "with the output mentioned below."
    )
    SAME_STANZA_MESSAGE_2 = (
        "Below are the file(s) where same stanzas are present in source and destination "
        "as UCC generates them you can remove them from your source one."
    )

    def __init__(self, src_dir: str, dst_dir: str) -> None:
        self.source_directory = src_dir
        self.target_directory = dst_dir
        # {src_full_file_name::attrib_name : [{repository: value, output: value}]}
        self.different_files: Dict[str, Any[Dict[str, str], List[Dict[str, str]]]] = {}
        # {src_full_file_name : short_file_name}
        self.common_files: Dict[str, str] = {}
        self.same_stanza:  Dict[str, str] = {}

    def deduce_gen_and_custom_content(
        self, logger: Logger, ignore_file_list: List[str] = []
    ) -> None:
        """
        Deduce that the files have same content or different
        - For the same content, developer can remove it from the repository
        - For the custom content, developer can raise enhancement request to UCC
        """
        # we add these two files as they are required to be present in source code
        # TODO: try to implement generation of these files from globalConfig
        ignore_file_list.extend(["app.manifest", "README.txt"])

        src_all_files: Dict[str, str] = {}
        for root, _, files in walk(self.source_directory):
            for file in files:
                src_all_files[file] = sep.join([root, file])

        dest_all_files: Dict[str, str] = {}
        for root, _, files in walk(self.target_directory):
            for file in files:
                dest_all_files[file] = sep.join([root, file])
        dest_all_files["default.meta"] = sep.join([self.target_directory, "metadata"])

        for file_name in dest_all_files.keys():
            if file_name in src_all_files.keys():
                if file_name in ignore_file_list:
                    continue
                if file_name.endswith(".conf"):
                    self._conf_file_diff_checker(
                        src_all_files[file_name], dest_all_files[file_name]
                    )
                # elif file_name.endswith((".xml", ".html")):
                #     self._xml_file_diff_checker(
                #         src_all_files[file_name], dest_all_files[file_name]
                #     )

        self.print_files(logger)
    
    def _conf_file_diff_checker(self, src_file: str, target_file: str) -> None:
        """
        Find the difference between the source code and generated code for the
        conf files created in package/default directory
        """

        """
        If src_dict and dst_dict are same then we can log COMMON_FILES_MESSAGE_PART_1 and COMMON_FILES_MESSAGE_PART_2 with which files are they. If found skip checking for that file.

        if src_dict contain something that we do not generate in general not present in dst dict then we have to log DIFFERENT_FILES_MESSAGE with file name 
        the diff can be in stanza or in key-value in any stanza.

        if src_dict contain stanzas or key-values that is present in dst_dict then we need to log diff msg stating that we do generate this so you can remove this part
        """
        sparser = conf_parser.TABConfigParser()
        sparser.read(src_file)
        src_dict = sparser.item_dict()
        parser = conf_parser.TABConfigParser()
        parser.read(target_file)
        dst_dict = parser.item_dict()

        if src_dict == dst_dict:
            self.common_files[src_file] = src_file.split(sep=sep)[-1]
        else:
            for stanza, src_kv in src_dict.items():
                dst_kv = dst_dict.get(stanza)

                # Stanza not present in destination
                if dst_kv is None:
                    for key, val in src_kv.items():
                        self.different_files[f"{src_file}[{stanza}] :: {key}"] = {
                            "repository": val,
                            "output": "",
                        }
                    continue

                # Stanza present, check individual key differences
                for key, val in src_kv.items():
                    if key not in dst_kv:
                        self.different_files[f"{src_file}[{stanza}] :: {key}"] = {
                            "repository": val,
                            "output": "",
                        }

                # If stanza dicts are identical, mark them as same stanza
                if src_kv == dst_kv:
                    self.same_stanza[f"{src_file} :: {stanza}"] = src_file.split(sep=sep)[-1]


    def _xml_file_diff_checker(self, src_file: str, target_file: str) -> None:
        """
        Find the difference between the source code and generated code for the
        XML or HTML files created in package/default/data directory
        """
        diff_count = len(self.different_files)
        parser = etree.XMLParser(remove_comments=True)
        try:
            src_tree = objectify.parse(src_file, parser=parser)
        except etree.XMLSyntaxError:
            self.different_files[src_file] = {
                "repository": "invalid XML present. Please update the source code with valid XML.",
                "output": "[unverified]",
            }
            return
        try:
            target_tree = objectify.parse(target_file, parser=parser)
        except etree.XMLSyntaxError:
            self.different_files[src_file] = {
                "repository": "[unverified]",
                "output": "invalid XML generated from globalConfig. Ensure necessary characters are escaped.",
            }
            return

        src_root = src_tree.getroot()
        target_root = target_tree.getroot()

        # remove all the code comments from the XML files, keep changes in-memory
        src_tree = remove_code_comments("xml", src_root)
        target_tree = remove_code_comments("xml", target_root)

        def __compare_elements(
            src_elem: etree._Element, target_elem: etree._Element
        ) -> None:
            if src_elem.tag != target_elem.tag:
                if self.different_files.get(f"{src_file}::{src_elem.tag}") is None:
                    self.different_files[f"{src_file}::{src_elem.tag}"] = []
                self.different_files[f"{src_file}::{src_elem.tag}"].append(
                    {"repository": src_elem.tag, "output": target_elem.tag}
                )

            if src_elem.text != target_elem.text:
                if self.different_files.get(f"{src_file}::{src_elem.tag}") is None:
                    self.different_files[f"{src_file}::{src_elem.tag}"] = []
                # strip the extra spaces from texts in XMLs
                self.different_files[f"{src_file}::{src_elem.tag}"].append(
                    {
                        "repository": src_elem.text.strip(),
                        "output": target_elem.text.strip(),
                    }
                )

            if src_elem.attrib != target_elem.attrib:
                if self.different_files.get(f"{src_file}::{src_elem.tag}") is None:
                    self.different_files[f"{src_file}::{src_elem.tag}"] = []
                self.different_files[f"{src_file}::{src_elem.tag}"].append(
                    {"repository": src_elem.attrib, "output": target_elem.attrib}
                )

            for child1, child2 in zip(src_elem, target_elem):
                # recursively check for tags, attributes, texts of XML
                __compare_elements(child1, child2)

        __compare_elements(src_root, target_root)
        if diff_count == len(self.different_files):
            self.common_files[src_file] = src_file.split(sep=sep)[-1]

    def print_files(self, logger: Logger) -> None:
        """
        Print the common and different files in the console
        """
        messages: List[str] = []
        if self.common_files:
            messages.append("-" * 120)
            messages.append(self.COMMON_FILES_MESSAGE_PART_1)
            messages.extend(
                [f"{idx + 1}) {f}" for idx, f in enumerate(self.common_files.keys())]
            )
            messages.append(self.COMMON_FILES_MESSAGE_PART_2)
            messages.append("-" * 120)
            logger.warning("\n\n".join(messages))

        messages.clear()

        if self.same_stanza:
            messages.append("-" * 120)
            messages.append(self.SAME_STANZA_MESSAGE_2)
            messages.extend(
                [f"{idx + 1}) {f}" for idx, f in enumerate(self.same_stanza.keys())]
            )
            messages.append("-" * 120)
            logger.warning("\n\n".join(messages))

        messages.clear()

        if self.different_files:
            messages.append("+" * 120)
            messages.append(self.DIFFERENT_FILES_MESSAGE)
            file_count = 1
            for k, v in self.different_files.items():
                # file_diff_count = 1
                file_msg: str = ""
                file_msg = f"{file_count}) {k}"
                if isinstance(v, dict):
                    file_msg += f"\n\tSource: {v.get('repository')}, Generated: {v.get('output')}"
                elif isinstance(v, list):
                    file_msg += "".join(
                        [
                            f"\n\tSource: {iv.get('repository')}, Generated: {iv.get('output')}"
                            for iv in v
                        ]
                    )
                messages.append(file_msg)
                file_count += 1
            messages.append("+" * 120)
            logger.warning("\n".join(messages))


def remove_code_comments(
    file_type: Union[Literal["xml"]], source_code: Union[etree.ElementTree]
) -> Union[etree.ElementTree, Exception]:
    """
    Remove comments from code files before parsing them
    """
    if file_type == "xml":
        for element in source_code.iter():
            for comment in element.xpath("//comment()"):
                parent = comment.getparent()
                parent.remove(comment)
        return source_code
    else:
        raise Exception("Unknown 'file_type' provided.")